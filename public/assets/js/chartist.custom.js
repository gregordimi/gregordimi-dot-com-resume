/* Chartist.js 0.9.8
 * Copyright © 2016 Gion Kunz
 * Free to use under either the WTFPL license or the MIT license.
 * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-WTFPL
 * https://raw.githubusercontent.com/gionkunz/chartist-js/master/LICENSE-MIT
 */
!function (e, t) { "function" == typeof define && define.amd ? define([], function () { return e.Chartist = t() }) : "object" == typeof exports ? module.exports = t() : e.Chartist = t() }(this, function () {
    var e = { version: "0.9.8" }; return function (e, t, n) { "use strict"; n.namespaces = { svg: "http://www.w3.org/2000/svg", xmlns: "http://www.w3.org/2000/xmlns/", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", ct: "http://gionkunz.github.com/chartist-js/ct" }, n.noop = function (e) { return e }, n.alphaNumerate = function (e) { return String.fromCharCode(97 + e % 26) }, n.extend = function (e) { e = e || {}; var t = Array.prototype.slice.call(arguments, 1); return t.forEach(function (t) { for (var i in t) e[i] = "object" != typeof t[i] || null === t[i] || t[i] instanceof Array ? t[i] : n.extend({}, e[i], t[i]) }), e }, n.replaceAll = function (e, t, n) { return e.replace(new RegExp(t, "g"), n) }, n.ensureUnit = function (e, t) { return "number" == typeof e && (e += t), e }, n.quantity = function (e) { if ("string" == typeof e) { var t = /^(\d+)\s*(.*)$/g.exec(e); return { value: +t[1], unit: t[2] || void 0 } } return { value: e } }, n.querySelector = function (e) { return e instanceof Node ? e : t.querySelector(e) }, n.times = function (e) { return Array.apply(null, new Array(e)) }, n.sum = function (e, t) { return e + (t ? t : 0) }, n.mapMultiply = function (e) { return function (t) { return t * e } }, n.mapAdd = function (e) { return function (t) { return t + e } }, n.serialMap = function (e, t) { var i = [], o = Math.max.apply(null, e.map(function (e) { return e.length })); return n.times(o).forEach(function (n, o) { var r = e.map(function (e) { return e[o] }); i[o] = t.apply(null, r) }), i }, n.roundWithPrecision = function (e, t) { var i = Math.pow(10, t || n.precision); return Math.round(e * i) / i }, n.precision = 8, n.escapingMap = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }, n.serialize = function (e) { return null === e || void 0 === e ? e : ("number" == typeof e ? e = "" + e : "object" == typeof e && (e = JSON.stringify({ data: e })), Object.keys(n.escapingMap).reduce(function (e, t) { return n.replaceAll(e, t, n.escapingMap[t]) }, e)) }, n.deserialize = function (e) { if ("string" != typeof e) return e; e = Object.keys(n.escapingMap).reduce(function (e, t) { return n.replaceAll(e, n.escapingMap[t], t) }, e); try { e = JSON.parse(e), e = void 0 !== e.data ? e.data : e } catch (t) { } return e }, n.createSvg = function (e, t, i, o) { var r; return t = t || "100%", i = i || "100%", Array.prototype.slice.call(e.querySelectorAll("svg")).filter(function (e) { return e.getAttributeNS(n.namespaces.xmlns, "ct") }).forEach(function (t) { e.removeChild(t) }), r = new n.Svg("svg").attr({ width: t, height: i }).addClass(o).attr({ style: "width: " + t + "; height: " + i + ";" }), e.appendChild(r._node), r }, n.normalizeData = function (e) { if (e = e || { series: [], labels: [] }, e.series = e.series || [], e.labels = e.labels || [], e.series.length > 0 && 0 === e.labels.length) { var t, i = n.getDataArray(e); t = i.every(function (e) { return e instanceof Array }) ? Math.max.apply(null, i.map(function (e) { return e.length })) : i.length, e.labels = n.times(t).map(function () { return "" }) } return e }, n.reverseData = function (e) { e.labels.reverse(), e.series.reverse(); for (var t = 0; t < e.series.length; t++)"object" == typeof e.series[t] && void 0 !== e.series[t].data ? e.series[t].data.reverse() : e.series[t] instanceof Array && e.series[t].reverse() }, n.getDataArray = function (e, t, i) { function o(e) { if (!n.isFalseyButZero(e)) { if ((e.data || e) instanceof Array) return (e.data || e).map(o); if (e.hasOwnProperty("value")) return o(e.value); if (i) { var t = {}; return "string" == typeof i ? t[i] = n.getNumberOrUndefined(e) : t.y = n.getNumberOrUndefined(e), t.x = e.hasOwnProperty("x") ? n.getNumberOrUndefined(e.x) : t.x, t.y = e.hasOwnProperty("y") ? n.getNumberOrUndefined(e.y) : t.y, t } return n.getNumberOrUndefined(e) } } return (t && !e.reversed || !t && e.reversed) && (n.reverseData(e), e.reversed = !e.reversed), e.series.map(o) }, n.normalizePadding = function (e, t) { return t = t || 0, "number" == typeof e ? { top: e, right: e, bottom: e, left: e } : { top: "number" == typeof e.top ? e.top : t, right: "number" == typeof e.right ? e.right : t, bottom: "number" == typeof e.bottom ? e.bottom : t, left: "number" == typeof e.left ? e.left : t } }, n.getMetaData = function (e, t) { var i = e.data ? e.data[t] : e[t]; return i ? n.serialize(i.meta) : void 0 }, n.orderOfMagnitude = function (e) { return Math.floor(Math.log(Math.abs(e)) / Math.LN10) }, n.projectLength = function (e, t, n) { return t / n.range * e }, n.getAvailableHeight = function (e, t) { return Math.max((n.quantity(t.height).value || e.height()) - (t.chartPadding.top + t.chartPadding.bottom) - t.axisX.offset, 0) }, n.getHighLow = function (e, t, i) { function o(e) { if (void 0 !== e) if (e instanceof Array) for (var t = 0; t < e.length; t++)o(e[t]); else { var n = i ? +e[i] : +e; s && n > r.high && (r.high = n), a && n < r.low && (r.low = n) } } t = n.extend({}, t, i ? t["axis" + i.toUpperCase()] : {}); var r = { high: void 0 === t.high ? -Number.MAX_VALUE : +t.high, low: void 0 === t.low ? Number.MAX_VALUE : +t.low }, s = void 0 === t.high, a = void 0 === t.low; return (s || a) && o(e), (t.referenceValue || 0 === t.referenceValue) && (r.high = Math.max(t.referenceValue, r.high), r.low = Math.min(t.referenceValue, r.low)), r.high <= r.low && (0 === r.low ? r.high = 1 : r.low < 0 ? r.high = 0 : r.high > 0 ? r.low = 0 : (r.high = 1, r.low = 0)), r }, n.isNum = function (e) { return !isNaN(e) && isFinite(e) }, n.isFalseyButZero = function (e) { return !e && 0 !== e }, n.getNumberOrUndefined = function (e) { return isNaN(+e) ? void 0 : +e }, n.getMultiValue = function (e, t) { return n.isNum(e) ? +e : e ? e[t || "y"] || 0 : 0 }, n.rho = function (e) { function t(e, n) { return e % n === 0 ? n : t(n, e % n) } function n(e) { return e * e + 1 } if (1 === e) return e; var i, o = 2, r = 2; if (e % 2 === 0) return 2; do o = n(o) % e, r = n(n(r)) % e, i = t(Math.abs(o - r), e); while (1 === i); return i }, n.getBounds = function (e, t, i, o) { var r, s, a, l = 0, c = { high: t.high, low: t.low }; c.valueRange = c.high - c.low, c.oom = n.orderOfMagnitude(c.valueRange), c.step = Math.pow(10, c.oom), c.min = Math.floor(c.low / c.step) * c.step, c.max = Math.ceil(c.high / c.step) * c.step, c.range = c.max - c.min, c.numberOfSteps = Math.round(c.range / c.step); var u = n.projectLength(e, c.step, c), d = i > u, f = o ? n.rho(c.range) : 0; if (o && n.projectLength(e, 1, c) >= i) c.step = 1; else if (o && f < c.step && n.projectLength(e, f, c) >= i) c.step = f; else for (; ;) { if (d && n.projectLength(e, c.step, c) <= i) c.step *= 2; else { if (d || !(n.projectLength(e, c.step / 2, c) >= i)) break; if (c.step /= 2, o && c.step % 1 !== 0) { c.step *= 2; break } } if (l++ > 1e3) throw new Error("Exceeded maximum number of iterations while optimizing scale step!") } var h = 2.221e-16; for (c.step = Math.max(c.step, h), s = c.min, a = c.max; s + c.step <= c.low;)s += c.step; for (; a - c.step >= c.high;)a -= c.step; c.min = s, c.max = a, c.range = c.max - c.min; var p = []; for (r = c.min; r <= c.max; r += c.step) { var m = n.roundWithPrecision(r); m !== p[p.length - 1] && p.push(r) } return c.values = p, c }, n.polarToCartesian = function (e, t, n, i) { var o = (i - 90) * Math.PI / 180; return { x: e + n * Math.cos(o), y: t + n * Math.sin(o) } }, n.createChartRect = function (e, t, i) { var o = !(!t.axisX && !t.axisY), r = o ? t.axisY.offset : 0, s = o ? t.axisX.offset : 0, a = e.width() || n.quantity(t.width).value || 0, l = e.height() || n.quantity(t.height).value || 0, c = n.normalizePadding(t.chartPadding, i); a = Math.max(a, r + c.left + c.right), l = Math.max(l, s + c.top + c.bottom); var u = { padding: c, width: function () { return this.x2 - this.x1 }, height: function () { return this.y1 - this.y2 } }; return o ? ("start" === t.axisX.position ? (u.y2 = c.top + s, u.y1 = Math.max(l - c.bottom, u.y2 + 1)) : (u.y2 = c.top, u.y1 = Math.max(l - c.bottom - s, u.y2 + 1)), "start" === t.axisY.position ? (u.x1 = c.left + r, u.x2 = Math.max(a - c.right, u.x1 + 1)) : (u.x1 = c.left, u.x2 = Math.max(a - c.right - r, u.x1 + 1))) : (u.x1 = c.left, u.x2 = Math.max(a - c.right, u.x1 + 1), u.y2 = c.top, u.y1 = Math.max(l - c.bottom, u.y2 + 1)), u }, n.createGrid = function (e, t, i, o, r, s, a, l) { var c = {}; c[i.units.pos + "1"] = e, c[i.units.pos + "2"] = e, c[i.counterUnits.pos + "1"] = o, c[i.counterUnits.pos + "2"] = o + r; var u = s.elem("line", c, a.join(" ")); l.emit("draw", n.extend({ type: "grid", axis: i, index: t, group: s, element: u }, c)) }, n.createLabel = function (e, t, i, o, r, s, a, l, c, u, d) { var f, h = {}; if (h[r.units.pos] = e + a[r.units.pos], h[r.counterUnits.pos] = a[r.counterUnits.pos], h[r.units.len] = t, h[r.counterUnits.len] = Math.max(0, s - 10), u) { var p = '<span class="' + c.join(" ") + '" style="' + r.units.len + ": " + Math.round(h[r.units.len]) + "px; " + r.counterUnits.len + ": " + Math.round(h[r.counterUnits.len]) + 'px">' + o[i] + "</span>"; f = l.foreignObject(p, n.extend({ style: "overflow: visible;" }, h)) } else f = l.elem("text", h, c.join(" ")).text(o[i]); d.emit("draw", n.extend({ type: "label", axis: r, index: i, group: l, element: f, text: o[i] }, h)) }, n.getSeriesOption = function (e, t, n) { if (e.name && t.series && t.series[e.name]) { var i = t.series[e.name]; return i.hasOwnProperty(n) ? i[n] : t[n] } return t[n] }, n.optionsProvider = function (t, i, o) { function r(t) { var r = a; if (a = n.extend({}, c), i) for (l = 0; l < i.length; l++) { var s = e.matchMedia(i[l][0]); s.matches && (a = n.extend(a, i[l][1])) } o && t && o.emit("optionsChanged", { previousOptions: r, currentOptions: a }) } function s() { u.forEach(function (e) { e.removeListener(r) }) } var a, l, c = n.extend({}, t), u = []; if (!e.matchMedia) throw "window.matchMedia not found! Make sure you're using a polyfill."; if (i) for (l = 0; l < i.length; l++) { var d = e.matchMedia(i[l][0]); d.addListener(r), u.push(d) } return r(), { removeMediaQueryListeners: s, getCurrentOptions: function () { return n.extend({}, a) } } }, n.splitIntoSegments = function (e, t, i) { var o = { increasingX: !1, fillHoles: !1 }; i = n.extend({}, o, i); for (var r = [], s = !0, a = 0; a < e.length; a += 2)void 0 === t[a / 2].value ? i.fillHoles || (s = !0) : (i.increasingX && a >= 2 && e[a] <= e[a - 2] && (s = !0), s && (r.push({ pathCoordinates: [], valueData: [] }), s = !1), r[r.length - 1].pathCoordinates.push(e[a], e[a + 1]), r[r.length - 1].valueData.push(t[a / 2])); return r } }(window, document, e), function (e, t, n) { "use strict"; n.Interpolation = {}, n.Interpolation.none = function (e) { var t = { fillHoles: !1 }; return e = n.extend({}, t, e), function (t, i) { for (var o = new n.Svg.Path, r = !0, s = 0; s < t.length; s += 2) { var a = t[s], l = t[s + 1], c = i[s / 2]; void 0 !== c.value ? (r ? o.move(a, l, !1, c) : o.line(a, l, !1, c), r = !1) : e.fillHoles || (r = !0) } return o } }, n.Interpolation.simple = function (e) { var t = { divisor: 2, fillHoles: !1 }; e = n.extend({}, t, e); var i = 1 / Math.max(1, e.divisor); return function (t, o) { for (var r, s, a, l = new n.Svg.Path, c = 0; c < t.length; c += 2) { var u = t[c], d = t[c + 1], f = (u - r) * i, h = o[c / 2]; void 0 !== h.value ? (void 0 === a ? l.move(u, d, !1, h) : l.curve(r + f, s, u - f, d, u, d, !1, h), r = u, s = d, a = h) : e.fillHoles || (r = u = a = void 0) } return l } }, n.Interpolation.cardinal = function (e) { var t = { tension: 1, fillHoles: !1 }; e = n.extend({}, t, e); var i = Math.min(1, Math.max(0, e.tension)), o = 1 - i; return function r(t, s) { var a = n.splitIntoSegments(t, s, { fillHoles: e.fillHoles }); if (a.length) { if (a.length > 1) { var l = []; return a.forEach(function (e) { l.push(r(e.pathCoordinates, e.valueData)) }), n.Svg.Path.join(l) } if (t = a[0].pathCoordinates, s = a[0].valueData, t.length <= 4) return n.Interpolation.none()(t, s); for (var c, u = (new n.Svg.Path).move(t[0], t[1], !1, s[0]), d = 0, f = t.length; f - 2 * !c > d; d += 2) { var h = [{ x: +t[d - 2], y: +t[d - 1] }, { x: +t[d], y: +t[d + 1] }, { x: +t[d + 2], y: +t[d + 3] }, { x: +t[d + 4], y: +t[d + 5] }]; c ? d ? f - 4 === d ? h[3] = { x: +t[0], y: +t[1] } : f - 2 === d && (h[2] = { x: +t[0], y: +t[1] }, h[3] = { x: +t[2], y: +t[3] }) : h[0] = { x: +t[f - 2], y: +t[f - 1] } : f - 4 === d ? h[3] = h[2] : d || (h[0] = { x: +t[d], y: +t[d + 1] }), u.curve(i * (-h[0].x + 6 * h[1].x + h[2].x) / 6 + o * h[2].x, i * (-h[0].y + 6 * h[1].y + h[2].y) / 6 + o * h[2].y, i * (h[1].x + 6 * h[2].x - h[3].x) / 6 + o * h[2].x, i * (h[1].y + 6 * h[2].y - h[3].y) / 6 + o * h[2].y, h[2].x, h[2].y, !1, s[(d + 2) / 2]) } return u } return n.Interpolation.none()([]) } }, n.Interpolation.monotoneCubic = function (e) { var t = { fillHoles: !1 }; return e = n.extend({}, t, e), function i(t, o) { var r = n.splitIntoSegments(t, o, { fillHoles: e.fillHoles, increasingX: !0 }); if (r.length) { if (r.length > 1) { var s = []; return r.forEach(function (e) { s.push(i(e.pathCoordinates, e.valueData)) }), n.Svg.Path.join(s) } if (t = r[0].pathCoordinates, o = r[0].valueData, t.length <= 4) return n.Interpolation.none()(t, o); var a, l, c = [], u = [], d = t.length / 2, f = [], h = [], p = [], m = []; for (a = 0; d > a; a++)c[a] = t[2 * a], u[a] = t[2 * a + 1]; for (a = 0; d - 1 > a; a++)p[a] = u[a + 1] - u[a], m[a] = c[a + 1] - c[a], h[a] = p[a] / m[a]; for (f[0] = h[0], f[d - 1] = h[d - 2], a = 1; d - 1 > a; a++)0 === h[a] || 0 === h[a - 1] || h[a - 1] > 0 != h[a] > 0 ? f[a] = 0 : (f[a] = 3 * (m[a - 1] + m[a]) / ((2 * m[a] + m[a - 1]) / h[a - 1] + (m[a] + 2 * m[a - 1]) / h[a]), isFinite(f[a]) || (f[a] = 0)); for (l = (new n.Svg.Path).move(c[0], u[0], !1, o[0]), a = 0; d - 1 > a; a++)l.curve(c[a] + m[a] / 3, u[a] + f[a] * m[a] / 3, c[a + 1] - m[a] / 3, u[a + 1] - f[a + 1] * m[a] / 3, c[a + 1], u[a + 1], !1, o[a + 1]); return l } return n.Interpolation.none()([]) } }, n.Interpolation.step = function (e) { var t = { postpone: !0, fillHoles: !1 }; return e = n.extend({}, t, e), function (t, i) { for (var o, r, s, a = new n.Svg.Path, l = 0; l < t.length; l += 2) { var c = t[l], u = t[l + 1], d = i[l / 2]; void 0 !== d.value ? (void 0 === s ? a.move(c, u, !1, d) : (e.postpone ? a.line(c, r, !1, s) : a.line(o, u, !1, d), a.line(c, u, !1, d)), o = c, r = u, s = d) : e.fillHoles || (o = r = s = void 0) } return a } } }(window, document, e), function (e, t, n) { "use strict"; n.EventEmitter = function () { function e(e, t) { i[e] = i[e] || [], i[e].push(t) } function t(e, t) { i[e] && (t ? (i[e].splice(i[e].indexOf(t), 1), 0 === i[e].length && delete i[e]) : delete i[e]) } function n(e, t) { i[e] && i[e].forEach(function (e) { e(t) }), i["*"] && i["*"].forEach(function (n) { n(e, t) }) } var i = []; return { addEventHandler: e, removeEventHandler: t, emit: n } } }(window, document, e), function (e, t, n) { "use strict"; function i(e) { var t = []; if (e.length) for (var n = 0; n < e.length; n++)t.push(e[n]); return t } function o(e, t) { var i = t || this.prototype || n.Class, o = Object.create(i); n.Class.cloneDefinitions(o, e); var r = function () { var e, t = o.constructor || function () { }; return e = this === n ? Object.create(o) : this, t.apply(e, Array.prototype.slice.call(arguments, 0)), e }; return r.prototype = o, r["super"] = i, r.extend = this.extend, r } function r() { var e = i(arguments), t = e[0]; return e.splice(1, e.length - 1).forEach(function (e) { Object.getOwnPropertyNames(e).forEach(function (n) { delete t[n], Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n)) }) }), t } n.Class = { extend: o, cloneDefinitions: r } }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, i) { return e && (this.data = e, this.eventEmitter.emit("data", { type: "update", data: this.data })), t && (this.options = n.extend({}, i ? this.options : this.defaultOptions, t), this.initializeTimeoutId || (this.optionsProvider.removeMediaQueryListeners(), this.optionsProvider = n.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter))), this.initializeTimeoutId || this.createChart(this.optionsProvider.getCurrentOptions()), this } function o() { return this.initializeTimeoutId ? e.clearTimeout(this.initializeTimeoutId) : (e.removeEventListener("resize", this.resizeListener), this.optionsProvider.removeMediaQueryListeners()), this } function r(e, t) { return this.eventEmitter.addEventHandler(e, t), this } function s(e, t) { return this.eventEmitter.removeEventHandler(e, t), this } function a() { e.addEventListener("resize", this.resizeListener), this.optionsProvider = n.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter), this.eventEmitter.addEventHandler("optionsChanged", function () { this.update() }.bind(this)), this.options.plugins && this.options.plugins.forEach(function (e) { e instanceof Array ? e[0](this, e[1]) : e(this) }.bind(this)), this.eventEmitter.emit("data", { type: "initial", data: this.data }), this.createChart(this.optionsProvider.getCurrentOptions()), this.initializeTimeoutId = void 0 } function l(e, t, i, o, r) { this.container = n.querySelector(e), this.data = t, this.defaultOptions = i, this.options = o, this.responsiveOptions = r, this.eventEmitter = n.EventEmitter(), this.supportsForeignObject = n.Svg.isSupported("Extensibility"), this.supportsAnimations = n.Svg.isSupported("AnimationEventsAttribute"), this.resizeListener = function () { this.update() }.bind(this), this.container && (this.container.__chartist__ && this.container.__chartist__.detach(), this.container.__chartist__ = this), this.initializeTimeoutId = setTimeout(a.bind(this), 0) } n.Base = n.Class.extend({ constructor: l, optionsProvider: void 0, container: void 0, svg: void 0, eventEmitter: void 0, createChart: function () { throw new Error("Base chart type can't be instantiated!") }, update: i, detach: o, on: r, off: s, version: n.version, supportsForeignObject: !1 }) }(window, document, e), function (e, t, n) { "use strict"; function i(e, i, o, r, s) { e instanceof Element ? this._node = e : (this._node = t.createElementNS(n.namespaces.svg, e), "svg" === e && this.attr({ "xmlns:ct": n.namespaces.ct })), i && this.attr(i), o && this.addClass(o), r && (s && r._node.firstChild ? r._node.insertBefore(this._node, r._node.firstChild) : r._node.appendChild(this._node)) } function o(e, t) { return "string" == typeof e ? t ? this._node.getAttributeNS(t, e) : this._node.getAttribute(e) : (Object.keys(e).forEach(function (t) { if (void 0 !== e[t]) if (-1 !== t.indexOf(":")) { var i = t.split(":"); this._node.setAttributeNS(n.namespaces[i[0]], t, e[t]) } else this._node.setAttribute(t, e[t]) }.bind(this)), this) } function r(e, t, i, o) { return new n.Svg(e, t, i, this, o) } function s() { return this._node.parentNode instanceof SVGElement ? new n.Svg(this._node.parentNode) : null } function a() { for (var e = this._node; "svg" !== e.nodeName;)e = e.parentNode; return new n.Svg(e) } function l(e) { var t = this._node.querySelector(e); return t ? new n.Svg(t) : null } function c(e) { var t = this._node.querySelectorAll(e); return t.length ? new n.Svg.List(t) : null } function u(e, i, o, r) { if ("string" == typeof e) { var s = t.createElement("div"); s.innerHTML = e, e = s.firstChild } e.setAttribute("xmlns", n.namespaces.xmlns); var a = this.elem("foreignObject", i, o, r); return a._node.appendChild(e), a } function d(e) { return this._node.appendChild(t.createTextNode(e)), this } function f() { for (; this._node.firstChild;)this._node.removeChild(this._node.firstChild); return this } function h() { return this._node.parentNode.removeChild(this._node), this.parent() } function p(e) { return this._node.parentNode.replaceChild(e._node, this._node), e } function m(e, t) { return t && this._node.firstChild ? this._node.insertBefore(e._node, this._node.firstChild) : this._node.appendChild(e._node), this } function v() { return this._node.getAttribute("class") ? this._node.getAttribute("class").trim().split(/\s+/) : [] } function g(e) { return this._node.setAttribute("class", this.classes(this._node).concat(e.trim().split(/\s+/)).filter(function (e, t, n) { return n.indexOf(e) === t }).join(" ")), this } function y(e) { var t = e.trim().split(/\s+/); return this._node.setAttribute("class", this.classes(this._node).filter(function (e) { return -1 === t.indexOf(e) }).join(" ")), this } function b() { return this._node.setAttribute("class", ""), this } function x() { return this._node.getBoundingClientRect().height } function w() { return this._node.getBoundingClientRect().width } function C(e, t, i) { return void 0 === t && (t = !0), Object.keys(e).forEach(function (o) { function r(e, t) { var r, s, a, l = {}; e.easing && (a = e.easing instanceof Array ? e.easing : n.Svg.Easing[e.easing], delete e.easing), e.begin = n.ensureUnit(e.begin, "ms"), e.dur = n.ensureUnit(e.dur, "ms"), a && (e.calcMode = "spline", e.keySplines = a.join(" "), e.keyTimes = "0;1"), t && (e.fill = "freeze", l[o] = e.from, this.attr(l), s = n.quantity(e.begin || 0).value, e.begin = "indefinite"), r = this.elem("animate", n.extend({ attributeName: o }, e)), t && setTimeout(function () { try { r._node.beginElement() } catch (t) { l[o] = e.to, this.attr(l), r.remove() } }.bind(this), s), i && r._node.addEventListener("beginEvent", function () { i.emit("animationBegin", { element: this, animate: r._node, params: e }) }.bind(this)), r._node.addEventListener("endEvent", function () { i && i.emit("animationEnd", { element: this, animate: r._node, params: e }), t && (l[o] = e.to, this.attr(l), r.remove()) }.bind(this)) } e[o] instanceof Array ? e[o].forEach(function (e) { r.bind(this)(e, !1) }.bind(this)) : r.bind(this)(e[o], t) }.bind(this)), this } function k(e) { var t = this; this.svgElements = []; for (var i = 0; i < e.length; i++)this.svgElements.push(new n.Svg(e[i])); Object.keys(n.Svg.prototype).filter(function (e) { return -1 === ["constructor", "parent", "querySelector", "querySelectorAll", "replace", "append", "classes", "height", "width"].indexOf(e) }).forEach(function (e) { t[e] = function () { var i = Array.prototype.slice.call(arguments, 0); return t.svgElements.forEach(function (t) { n.Svg.prototype[e].apply(t, i) }), t } }) } n.Svg = n.Class.extend({ constructor: i, attr: o, elem: r, parent: s, root: a, querySelector: l, querySelectorAll: c, foreignObject: u, text: d, empty: f, remove: h, replace: p, append: m, classes: v, addClass: g, removeClass: y, removeAllClasses: b, height: x, width: w, animate: C }), n.Svg.isSupported = function (e) { return t.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#" + e, "1.1") }; var T = { easeInSine: [.47, 0, .745, .715], easeOutSine: [.39, .575, .565, 1], easeInOutSine: [.445, .05, .55, .95], easeInQuad: [.55, .085, .68, .53], easeOutQuad: [.25, .46, .45, .94], easeInOutQuad: [.455, .03, .515, .955], easeInCubic: [.55, .055, .675, .19], easeOutCubic: [.215, .61, .355, 1], easeInOutCubic: [.645, .045, .355, 1], easeInQuart: [.895, .03, .685, .22], easeOutQuart: [.165, .84, .44, 1], easeInOutQuart: [.77, 0, .175, 1], easeInQuint: [.755, .05, .855, .06], easeOutQuint: [.23, 1, .32, 1], easeInOutQuint: [.86, 0, .07, 1], easeInExpo: [.95, .05, .795, .035], easeOutExpo: [.19, 1, .22, 1], easeInOutExpo: [1, 0, 0, 1], easeInCirc: [.6, .04, .98, .335], easeOutCirc: [.075, .82, .165, 1], easeInOutCirc: [.785, .135, .15, .86], easeInBack: [.6, -.28, .735, .045], easeOutBack: [.175, .885, .32, 1.275], easeInOutBack: [.68, -.55, .265, 1.55] }; n.Svg.Easing = T, n.Svg.List = n.Class.extend({ constructor: k }) }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, i, o, r, s) { var a = n.extend({ command: r ? e.toLowerCase() : e.toUpperCase() }, t, s ? { data: s } : {}); i.splice(o, 0, a) } function o(e, t) { e.forEach(function (n, i) { x[n.command.toLowerCase()].forEach(function (o, r) { t(n, o, i, r, e) }) }) } function r(e, t) { this.pathElements = [], this.pos = 0, this.close = e, this.options = n.extend({}, w, t) } function s(e) { return void 0 !== e ? (this.pos = Math.max(0, Math.min(this.pathElements.length, e)), this) : this.pos } function a(e) { return this.pathElements.splice(this.pos, e), this } function l(e, t, n, o) { return i("M", { x: +e, y: +t }, this.pathElements, this.pos++, n, o), this } function c(e, t, n, o) { return i("L", { x: +e, y: +t }, this.pathElements, this.pos++, n, o), this } function u(e, t, n, o, r, s, a, l) { return i("C", { x1: +e, y1: +t, x2: +n, y2: +o, x: +r, y: +s }, this.pathElements, this.pos++, a, l), this } function d(e, t, n, o, r, s, a, l, c) { return i("A", { rx: +e, ry: +t, xAr: +n, lAf: +o, sf: +r, x: +s, y: +a }, this.pathElements, this.pos++, l, c), this } function f(e) { var t = e.replace(/([A-Za-z])([0-9])/g, "$1 $2").replace(/([0-9])([A-Za-z])/g, "$1 $2").split(/[\s,]+/).reduce(function (e, t) { return t.match(/[A-Za-z]/) && e.push([]), e[e.length - 1].push(t), e }, []); "Z" === t[t.length - 1][0].toUpperCase() && t.pop(); var i = t.map(function (e) { var t = e.shift(), i = x[t.toLowerCase()]; return n.extend({ command: t }, i.reduce(function (t, n, i) { return t[n] = +e[i], t }, {})) }), o = [this.pos, 0]; return Array.prototype.push.apply(o, i), Array.prototype.splice.apply(this.pathElements, o), this.pos += i.length, this } function h() { var e = Math.pow(10, this.options.accuracy); return this.pathElements.reduce(function (t, n) { var i = x[n.command.toLowerCase()].map(function (t) { return this.options.accuracy ? Math.round(n[t] * e) / e : n[t] }.bind(this)); return t + n.command + i.join(",") }.bind(this), "") + (this.close ? "Z" : "") } function p(e, t) { return o(this.pathElements, function (n, i) { n[i] *= "x" === i[0] ? e : t }), this } function m(e, t) { return o(this.pathElements, function (n, i) { n[i] += "x" === i[0] ? e : t }), this } function v(e) { return o(this.pathElements, function (t, n, i, o, r) { var s = e(t, n, i, o, r); (s || 0 === s) && (t[n] = s) }), this } function g(e) { var t = new n.Svg.Path(e || this.close); return t.pos = this.pos, t.pathElements = this.pathElements.slice().map(function (e) { return n.extend({}, e) }), t.options = n.extend({}, this.options), t } function y(e) { var t = [new n.Svg.Path]; return this.pathElements.forEach(function (i) { i.command === e.toUpperCase() && 0 !== t[t.length - 1].pathElements.length && t.push(new n.Svg.Path), t[t.length - 1].pathElements.push(i) }), t } function b(e, t, i) { for (var o = new n.Svg.Path(t, i), r = 0; r < e.length; r++)for (var s = e[r], a = 0; a < s.pathElements.length; a++)o.pathElements.push(s.pathElements[a]); return o } var x = { m: ["x", "y"], l: ["x", "y"], c: ["x1", "y1", "x2", "y2", "x", "y"], a: ["rx", "ry", "xAr", "lAf", "sf", "x", "y"] }, w = { accuracy: 3 }; n.Svg.Path = n.Class.extend({ constructor: r, position: s, remove: a, move: l, line: c, curve: u, arc: d, scale: p, translate: m, transform: v, parse: f, stringify: h, clone: g, splitByCommand: y }), n.Svg.Path.elementDescriptions = x, n.Svg.Path.join = b }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, n, i) { this.units = e, this.counterUnits = e === r.x ? r.y : r.x, this.chartRect = t, this.axisLength = t[e.rectEnd] - t[e.rectStart], this.gridOffset = t[e.rectOffset], this.ticks = n, this.options = i } function o(e, t, i, o, r) { var s = o["axis" + this.units.pos.toUpperCase()], a = this.ticks.map(this.projectValue.bind(this)), l = this.ticks.map(s.labelInterpolationFnc); a.forEach(function (c, u) { var d, f = { x: 0, y: 0 }; d = a[u + 1] ? a[u + 1] - c : Math.max(this.axisLength - c, 30), n.isFalseyButZero(l[u]) && "" !== l[u] || ("x" === this.units.pos ? (c = this.chartRect.x1 + c, f.x = o.axisX.labelOffset.x, f.y = "start" === o.axisX.position ? this.chartRect.padding.top + o.axisX.labelOffset.y + (i ? 5 : 20) : this.chartRect.y1 + o.axisX.labelOffset.y + (i ? 5 : 20)) : (c = this.chartRect.y1 - c, f.y = o.axisY.labelOffset.y - (i ? d : 0), f.x = "start" === o.axisY.position ? i ? this.chartRect.padding.left + o.axisY.labelOffset.x : this.chartRect.x1 - 10 : this.chartRect.x2 + o.axisY.labelOffset.x + 10), s.showGrid && n.createGrid(c, u, this, this.gridOffset, this.chartRect[this.counterUnits.len](), e, [o.classNames.grid, o.classNames[this.units.dir]], r), s.showLabel && n.createLabel(c, d, u, l, this, s.offset, f, t, [o.classNames.label, o.classNames[this.units.dir], o.classNames[s.position]], i, r)) }.bind(this)) } var r = { x: { pos: "x", len: "width", dir: "horizontal", rectStart: "x1", rectEnd: "x2", rectOffset: "y2" }, y: { pos: "y", len: "height", dir: "vertical", rectStart: "y2", rectEnd: "y1", rectOffset: "x1" } }; n.Axis = n.Class.extend({ constructor: i, createGridAndLabels: o, projectValue: function () { throw new Error("Base axis can't be instantiated!") } }), n.Axis.units = r }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, i, o) { var r = o.highLow || n.getHighLow(t.normalized, o, e.pos); this.bounds = n.getBounds(i[e.rectEnd] - i[e.rectStart], r, o.scaleMinSpace || 20, o.onlyInteger), this.range = { min: this.bounds.min, max: this.bounds.max }, n.AutoScaleAxis["super"].constructor.call(this, e, i, this.bounds.values, o) } function o(e) { return this.axisLength * (+n.getMultiValue(e, this.units.pos) - this.bounds.min) / this.bounds.range } n.AutoScaleAxis = n.Axis.extend({ constructor: i, projectValue: o }) }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, i, o) { var r = o.highLow || n.getHighLow(t.normalized, o, e.pos); this.divisor = o.divisor || 1, this.ticks = o.ticks || n.times(this.divisor).map(function (e, t) { return r.low + (r.high - r.low) / this.divisor * t }.bind(this)), this.ticks.sort(function (e, t) { return e - t }), this.range = { min: r.low, max: r.high }, n.FixedScaleAxis["super"].constructor.call(this, e, i, this.ticks, o), this.stepLength = this.axisLength / this.divisor } function o(e) { return this.axisLength * (+n.getMultiValue(e, this.units.pos) - this.range.min) / (this.range.max - this.range.min) } n.FixedScaleAxis = n.Axis.extend({ constructor: i, projectValue: o }) }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, i, o) { n.StepAxis["super"].constructor.call(this, e, i, o.ticks, o), this.stepLength = this.axisLength / (o.ticks.length - (o.stretch ? 1 : 0)) } function o(e, t) { return this.stepLength * t } n.StepAxis = n.Axis.extend({ constructor: i, projectValue: o }) }(window, document, e), function (e, t, n) { "use strict"; function i(e) { this.data = n.normalizeData(this.data); var t = { raw: this.data, normalized: n.getDataArray(this.data, e.reverseData, !0) }; this.svg = n.createSvg(this.container, e.width, e.height, e.classNames.chart); var i, o, s = this.svg.elem("g").addClass(e.classNames.gridGroup), a = this.svg.elem("g"), l = this.svg.elem("g").addClass(e.classNames.labelGroup), c = n.createChartRect(this.svg, e, r.padding); i = void 0 === e.axisX.type ? new n.StepAxis(n.Axis.units.x, t, c, n.extend({}, e.axisX, { ticks: t.raw.labels, stretch: e.fullWidth })) : e.axisX.type.call(n, n.Axis.units.x, t, c, e.axisX), o = void 0 === e.axisY.type ? new n.AutoScaleAxis(n.Axis.units.y, t, c, n.extend({}, e.axisY, { high: n.isNum(e.high) ? e.high : e.axisY.high, low: n.isNum(e.low) ? e.low : e.axisY.low })) : e.axisY.type.call(n, n.Axis.units.y, t, c, e.axisY), i.createGridAndLabels(s, l, this.supportsForeignObject, e, this.eventEmitter), o.createGridAndLabels(s, l, this.supportsForeignObject, e, this.eventEmitter), t.raw.series.forEach(function (r, s) { var l = a.elem("g"); l.attr({ "ct:series-name": r.name, "ct:meta": n.serialize(r.meta) }), l.addClass([e.classNames.series, r.className || e.classNames.series + "-" + n.alphaNumerate(s)].join(" ")); var u = [], d = []; t.normalized[s].forEach(function (e, a) { var l = { x: c.x1 + i.projectValue(e, a, t.normalized[s]), y: c.y1 - o.projectValue(e, a, t.normalized[s]) }; u.push(l.x, l.y), d.push({ value: e, valueIndex: a, meta: n.getMetaData(r, a) }) }.bind(this)); var f = { lineSmooth: n.getSeriesOption(r, e, "lineSmooth"), showPoint: n.getSeriesOption(r, e, "showPoint"), showLine: n.getSeriesOption(r, e, "showLine"), showArea: n.getSeriesOption(r, e, "showArea"), areaBase: n.getSeriesOption(r, e, "areaBase") }, h = "function" == typeof f.lineSmooth ? f.lineSmooth : f.lineSmooth ? n.Interpolation.monotoneCubic() : n.Interpolation.none(), p = h(u, d); if (f.showPoint && p.pathElements.forEach(function (t) { var a = l.elem("line", { x1: t.x, y1: t.y, x2: t.x + .01, y2: t.y }, e.classNames.point).attr({ "ct:value": [t.data.value.x, t.data.value.y].filter(n.isNum).join(","), "ct:meta": t.data.meta }); this.eventEmitter.emit("draw", { type: "point", value: t.data.value, index: t.data.valueIndex, meta: t.data.meta, series: r, seriesIndex: s, axisX: i, axisY: o, group: l, element: a, x: t.x, y: t.y }) }.bind(this)), f.showLine) { var m = l.elem("path", { d: p.stringify() }, e.classNames.line, !0); this.eventEmitter.emit("draw", { type: "line", values: t.normalized[s], path: p.clone(), chartRect: c, index: s, series: r, seriesIndex: s, axisX: i, axisY: o, group: l, element: m }) } if (f.showArea && o.range) { var v = Math.max(Math.min(f.areaBase, o.range.max), o.range.min), g = c.y1 - o.projectValue(v); p.splitByCommand("M").filter(function (e) { return e.pathElements.length > 1 }).map(function (e) { var t = e.pathElements[0], n = e.pathElements[e.pathElements.length - 1]; return e.clone(!0).position(0).remove(1).move(t.x, g).line(t.x, t.y).position(e.pathElements.length + 1).line(n.x, g) }).forEach(function (n) { var a = l.elem("path", { d: n.stringify() }, e.classNames.area, !0); this.eventEmitter.emit("draw", { type: "area", values: t.normalized[s], path: n.clone(), series: r, seriesIndex: s, axisX: i, axisY: o, chartRect: c, index: s, group: l, element: a }) }.bind(this)) } }.bind(this)), this.eventEmitter.emit("created", { bounds: o.bounds, chartRect: c, axisX: i, axisY: o, svg: this.svg, options: e }) } function o(e, t, i, o) { n.Line["super"].constructor.call(this, e, t, r, n.extend({}, r, i), o) } var r = { axisX: { offset: 30, position: "end", labelOffset: { x: 0, y: 0 }, showLabel: !0, showGrid: !0, labelInterpolationFnc: n.noop, type: void 0 }, axisY: { offset: 40, position: "start", labelOffset: { x: 0, y: 0 }, showLabel: !0, showGrid: !0, labelInterpolationFnc: n.noop, type: void 0, scaleMinSpace: 20, onlyInteger: !1 }, width: void 0, height: void 0, showLine: !0, showPoint: !0, showArea: !1, areaBase: 0, lineSmooth: !0, low: void 0, high: void 0, chartPadding: { top: 15, right: 15, bottom: 5, left: 10 }, fullWidth: !1, reverseData: !1, classNames: { chart: "ct-chart-line", label: "ct-label", labelGroup: "ct-labels", series: "ct-series", line: "ct-line", point: "ct-point", area: "ct-area", grid: "ct-grid", gridGroup: "ct-grids", vertical: "ct-vertical", horizontal: "ct-horizontal", start: "ct-start", end: "ct-end" } }; n.Line = n.Base.extend({ constructor: o, createChart: i }) }(window, document, e), function (e, t, n) {
        "use strict"; function i(e) {
            this.data = n.normalizeData(this.data); var t, i = { raw: this.data, normalized: e.distributeSeries ? n.getDataArray(this.data, e.reverseData, e.horizontalBars ? "x" : "y").map(function (e) { return [e] }) : n.getDataArray(this.data, e.reverseData, e.horizontalBars ? "x" : "y") }; this.svg = n.createSvg(this.container, e.width, e.height, e.classNames.chart + (e.horizontalBars ? " " + e.classNames.horizontalBars : "")); var o = this.svg.elem("g").addClass(e.classNames.gridGroup), s = this.svg.elem("g"), a = this.svg.elem("g").addClass(e.classNames.labelGroup); if (e.stackBars && 0 !== i.normalized.length) { var l = n.serialMap(i.normalized, function () { return Array.prototype.slice.call(arguments).map(function (e) { return e }).reduce(function (e, t) { return { x: e.x + (t && t.x) || 0, y: e.y + (t && t.y) || 0 } }, { x: 0, y: 0 }) }); t = n.getHighLow([l], n.extend({}, e, { referenceValue: 0 }), e.horizontalBars ? "x" : "y") } else t = n.getHighLow(i.normalized, n.extend({}, e, { referenceValue: 0 }), e.horizontalBars ? "x" : "y"); t.high = +e.high || (0 === e.high ? 0 : t.high), t.low = +e.low || (0 === e.low ? 0 : t.low); var c, u, d, f, h, p = n.createChartRect(this.svg, e, r.padding); u = e.distributeSeries && e.stackBars ? i.raw.labels.slice(0, 1) : i.raw.labels, e.horizontalBars ? (c = f = void 0 === e.axisX.type ? new n.AutoScaleAxis(n.Axis.units.x, i, p, n.extend({}, e.axisX, { highLow: t, referenceValue: 0 })) : e.axisX.type.call(n, n.Axis.units.x, i, p, n.extend({}, e.axisX, { highLow: t, referenceValue: 0 })), d = h = void 0 === e.axisY.type ? new n.StepAxis(n.Axis.units.y, i, p, { ticks: u }) : e.axisY.type.call(n, n.Axis.units.y, i, p, e.axisY)) : (d = f = void 0 === e.axisX.type ? new n.StepAxis(n.Axis.units.x, i, p, { ticks: u }) : e.axisX.type.call(n, n.Axis.units.x, i, p, e.axisX), c = h = void 0 === e.axisY.type ? new n.AutoScaleAxis(n.Axis.units.y, i, p, n.extend({}, e.axisY, { highLow: t, referenceValue: 0 })) : e.axisY.type.call(n, n.Axis.units.y, i, p, n.extend({}, e.axisY, { highLow: t, referenceValue: 0 }))); var m = e.horizontalBars ? p.x1 + c.projectValue(0) : p.y1 - c.projectValue(0), v = []; d.createGridAndLabels(o, a, this.supportsForeignObject, e, this.eventEmitter), c.createGridAndLabels(o, a, this.supportsForeignObject, e, this.eventEmitter), i.raw.series.forEach(function (t, o) {
                var r, a, l = o - (i.raw.series.length - 1) / 2; r = e.distributeSeries && !e.stackBars ? d.axisLength / i.normalized.length / 2 : e.distributeSeries && e.stackBars ? d.axisLength / 2 : d.axisLength / i.normalized[o].length / 2, a = s.elem("g"), a.attr({ "ct:series-name": t.name, "ct:meta": n.serialize(t.meta) }), a.addClass([e.classNames.series, t.className || e.classNames.series + "-" + n.alphaNumerate(o)].join(" ")), i.normalized[o].forEach(function (s, u) {
                    var g, y, b, x; if (x = e.distributeSeries && !e.stackBars ? o : e.distributeSeries && e.stackBars ? 0 : u, g = e.horizontalBars ? { x: p.x1 + c.projectValue(s && s.x ? s.x : 0, u, i.normalized[o]), y: p.y1 - d.projectValue(s && s.y ? s.y : 0, x, i.normalized[o]) } : { x: p.x1 + d.projectValue(s && s.x ? s.x : 0, x, i.normalized[o]), y: p.y1 - c.projectValue(s && s.y ? s.y : 0, u, i.normalized[o]) }, d instanceof n.StepAxis && (d.options.stretch || (g[d.units.pos] += r * (e.horizontalBars ? -1 : 1)), g[d.units.pos] += e.stackBars || e.distributeSeries ? 0 : l * e.seriesBarDistance * (e.horizontalBars ? -1 : 1)), b = v[u] || m, v[u] = b - (m - g[d.counterUnits.pos]), void 0 !== s) {
                        var w = {};
                        w[d.units.pos + "1"] = g[d.units.pos], w[d.units.pos + "2"] = g[d.units.pos], !e.stackBars || "accumulate" !== e.stackMode && e.stackMode ? (w[d.counterUnits.pos + "1"] = m, w[d.counterUnits.pos + "2"] = g[d.counterUnits.pos]) : (w[d.counterUnits.pos + "1"] = b, w[d.counterUnits.pos + "2"] = v[u]), w.x1 = Math.min(Math.max(w.x1, p.x1), p.x2), w.x2 = Math.min(Math.max(w.x2, p.x1), p.x2), w.y1 = Math.min(Math.max(w.y1, p.y2), p.y1), w.y2 = Math.min(Math.max(w.y2, p.y2), p.y1), y = a.elem("line", w, e.classNames.bar).attr({ "ct:value": [s.x, s.y].filter(n.isNum).join(","), "ct:meta": n.getMetaData(t, u) }), this.eventEmitter.emit("draw", n.extend({ type: "bar", value: s, index: u, meta: n.getMetaData(t, u), series: t, seriesIndex: o, axisX: f, axisY: h, chartRect: p, group: a, element: y }, w))
                    }
                }.bind(this))
            }.bind(this)), this.eventEmitter.emit("created", { bounds: c.bounds, chartRect: p, axisX: f, axisY: h, svg: this.svg, options: e })
        } function o(e, t, i, o) { n.Bar["super"].constructor.call(this, e, t, r, n.extend({}, r, i), o) } var r = { axisX: { offset: 30, position: "end", labelOffset: { x: 0, y: 0 }, showLabel: !0, showGrid: !0, labelInterpolationFnc: n.noop, scaleMinSpace: 30, onlyInteger: !1 }, axisY: { offset: 40, position: "start", labelOffset: { x: 0, y: 0 }, showLabel: !0, showGrid: !0, labelInterpolationFnc: n.noop, scaleMinSpace: 20, onlyInteger: !1 }, width: void 0, height: void 0, high: void 0, low: void 0, chartPadding: { top: 15, right: 15, bottom: 5, left: 10 }, seriesBarDistance: 15, stackBars: !1, stackMode: "accumulate", horizontalBars: !1, distributeSeries: !1, reverseData: !1, classNames: { chart: "ct-chart-bar", horizontalBars: "ct-horizontal-bars", label: "ct-label", labelGroup: "ct-labels", series: "ct-series", bar: "ct-bar", grid: "ct-grid", gridGroup: "ct-grids", vertical: "ct-vertical", horizontal: "ct-horizontal", start: "ct-start", end: "ct-end" } }; n.Bar = n.Base.extend({ constructor: o, createChart: i })
    }(window, document, e), function (e, t, n) { "use strict"; function i(e, t, n) { var i = t.x > e.x; return i && "explode" === n || !i && "implode" === n ? "start" : i && "implode" === n || !i && "explode" === n ? "end" : "middle" } function o(e) { this.data = n.normalizeData(this.data); var t, o, r, a, l, c = [], u = e.startAngle, d = n.getDataArray(this.data, e.reverseData); this.svg = n.createSvg(this.container, e.width, e.height, e.donut ? e.classNames.chartDonut : e.classNames.chartPie), o = n.createChartRect(this.svg, e, s.padding), r = Math.min(o.width() / 2, o.height() / 2), l = e.total || d.reduce(function (e, t) { return e + t }, 0); var f = n.quantity(e.donutWidth); "%" === f.unit && (f.value *= r / 100), r -= e.donut ? f.value / 2 : 0, a = "outside" === e.labelPosition || e.donut ? r : "center" === e.labelPosition ? 0 : r / 2, a += e.labelOffset; var h = { x: o.x1 + o.width() / 2, y: o.y2 + o.height() / 2 }, p = 1 === this.data.series.filter(function (e) { return e.hasOwnProperty("value") ? 0 !== e.value : 0 !== e }).length; e.showLabel && (t = this.svg.elem("g", null, null, !0)); for (var m = 0; m < this.data.series.length; m++)if (0 !== d[m] || !e.ignoreEmptyValues) { var v = this.data.series[m]; c[m] = this.svg.elem("g", null, null, !0), c[m].attr({ "ct:series-name": v.name }), c[m].addClass([e.classNames.series, v.className || e.classNames.series + "-" + n.alphaNumerate(m)].join(" ")); var g = u + d[m] / l * 360, y = Math.max(0, u - (0 === m || p ? 0 : .2)); g - y >= 359.99 && (g = y + 359.99); var b = n.polarToCartesian(h.x, h.y, r, y), x = n.polarToCartesian(h.x, h.y, r, g), w = new n.Svg.Path(!e.donut).move(x.x, x.y).arc(r, r, 0, g - u > 180, 0, b.x, b.y); e.donut || w.line(h.x, h.y); var C = c[m].elem("path", { d: w.stringify() }, e.donut ? e.classNames.sliceDonut : e.classNames.slicePie); if (C.attr({ "ct:value": d[m], "ct:meta": n.serialize(v.meta) }), e.donut && C.attr({ style: "stroke-width: " + f.value + "px" }), this.eventEmitter.emit("draw", { type: "slice", value: d[m], totalDataSum: l, index: m, meta: v.meta, series: v, group: c[m], element: C, path: w.clone(), center: h, radius: r, startAngle: u, endAngle: g }), e.showLabel) { var k = n.polarToCartesian(h.x, h.y, a, u + (g - u) / 2), T = e.labelInterpolationFnc(this.data.labels && !n.isFalseyButZero(this.data.labels[m]) ? this.data.labels[m] : d[m], m); if (T || 0 === T) { var $ = t.elem("text", { dx: k.x, dy: k.y, "text-anchor": i(h, k, e.labelDirection) }, e.classNames.label).text("" + T); this.eventEmitter.emit("draw", { type: "label", index: m, group: t, element: $, text: "" + T, x: k.x, y: k.y }) } } u = g } this.eventEmitter.emit("created", { chartRect: o, svg: this.svg, options: e }) } function r(e, t, i, o) { n.Pie["super"].constructor.call(this, e, t, s, n.extend({}, s, i), o) } var s = { width: void 0, height: void 0, chartPadding: 5, classNames: { chartPie: "ct-chart-pie", chartDonut: "ct-chart-donut", series: "ct-series", slicePie: "ct-slice-pie", sliceDonut: "ct-slice-donut", label: "ct-label" }, startAngle: 0, total: void 0, donut: !1, donutWidth: 60, showLabel: !0, labelOffset: 0, labelPosition: "inside", labelInterpolationFnc: n.noop, labelDirection: "neutral", reverseData: !1, ignoreEmptyValues: !1 }; n.Pie = n.Base.extend({ constructor: r, createChart: o, determineAnchorPosition: i }) }(window, document, e), e
}), function (e, t) { "function" == typeof define && define.amd ? define(["chartist"], function (n) { return e.returnExportsGlobal = t(n) }) : "object" == typeof exports ? module.exports = t(require("chartist")) : e["Chartist.plugins.legend"] = t(e.Chartist) }(this, function (e) { "use strict"; var t = { className: "", classNames: !1, removeAll: !1, legendNames: !1, clickable: !0, onClick: null, position: "top" }; return e.plugins = e.plugins || {}, e.plugins.legend = function (n) { function i(e, t) { return e - t } if (n && n.position && "top" !== n.position && "bottom" !== n.position) throw Error("The position you entered is not a valid position"); return n = e.extend({}, t, n), function (t) { var o = t.container.querySelector(".ct-legend"); if (o && o.parentNode.removeChild(o), n.clickable) { var r = t.data.series.map(function (n, i) { return "object" != typeof n && (n = { value: n }), n.className = n.className || t.options.classNames.series + "-" + e.alphaNumerate(i), n }); t.data.series = r } var s = document.createElement("ul"), a = t instanceof e.Pie; s.className = "ct-legend", t instanceof e.Pie && s.classList.add("ct-legend-inside"), "string" == typeof n.className && n.className.length > 0 && s.classList.add(n.className); var l = [], c = t.data.series.slice(0), u = t.data.series, d = a && t.data.labels; if (d) { var f = t.data.labels.slice(0); u = t.data.labels } u = n.legendNames || u; var h = Array.isArray(n.classNames) && n.classNames.length === u.length; u.forEach(function (e, t) { var i = document.createElement("li"); i.className = "ct-series-" + t, h && (i.className += " " + n.classNames[t]), i.setAttribute("data-legend", t), i.textContent = e.name || e, s.appendChild(i) }), t.on("created", function () { switch (n.position) { case "top": t.container.insertBefore(s, t.container.childNodes[0]); break; case "bottom": t.container.insertBefore(s, null) } }), n.clickable && s.addEventListener("click", function (e) { var o = e.target; if (o.parentNode === s && o.hasAttribute("data-legend")) { e.preventDefault(); var r = parseInt(o.getAttribute("data-legend")), a = l.indexOf(r); if (a > -1) l.splice(a, 1), o.classList.remove("inactive"); else if (n.removeAll) l.push(r), o.classList.add("inactive"); else if (t.data.series.length > 1) l.push(r), o.classList.add("inactive"); else { l = []; var u = Array.prototype.slice.call(s.childNodes); u.forEach(function (e) { e.classList.remove("inactive") }) } var h = c.slice(0); if (d) var p = f.slice(0); l.sort(i).reverse(), l.forEach(function (e) { h.splice(e, 1), d && p.splice(e, 1) }), n.onClick && n.onClick(t, e), t.data.series = h, d && (t.data.labels = p), t.update() } }) } }, e.plugins.legend }),/* chartist-plugin-axistitle 0.0.1
 * Copyright © 2015 Alex Stanbury
 * Free to use under the WTFPL license.
 * http://www.wtfpl.net/
 */
    !function (e, t) { "function" == typeof define && define.amd ? define([], function () { return e.returnExportsGlobal = t() }) : "object" == typeof exports ? module.exports = t() : e["Chartist.plugins.ctAxisTitle"] = t() }(this, function () { return function (e, t, n) { "use strict"; var i = { axisTitle: "", axisClass: "ct-axis-title", offset: { x: 0, y: 0 }, textAnchor: "middle", flipText: !1 }, o = { xAxis: i, yAxis: i }; n.plugins = n.plugins || {}, n.plugins.ctAxisTitle = function (e) { return e = n.extend({}, o, e), function (t) { t.on("created", function (t) { if (!e.axisX.axisTitle && !e.axisY.axisTitle) throw new Error("ctAxisTitle plugin - You must provide at least one axis title"); if (!t.axisX && !t.axisY) throw new Error("ctAxisTitle plugin can only be used on charts that have at least one axis"); var i, o, r; if (e.axisX.axisTitle && t.axisX && (i = t.axisX.axisLength / 2 + t.options.axisY.offset + t.options.chartPadding.left, o = t.options.chartPadding.top, "end" === t.options.axisY.position && (i -= t.options.axisY.offset), "end" === t.options.axisX.position && (o += t.axisY.axisLength), r = new n.Svg("text"), r.addClass(e.axisX.axisClass), r.text(e.axisX.axisTitle), r.attr({ x: i + e.axisX.offset.x, y: o + e.axisX.offset.y, "text-anchor": e.axisX.textAnchor }), t.svg.append(r, !0)), e.axisY.axisTitle && t.axisY) { i = 0, o = t.axisY.axisLength / 2 + t.options.chartPadding.top, "start" === t.options.axisX.position && (o += t.options.axisX.offset), "end" === t.options.axisY.position && (i = t.axisX.axisLength); var s = "rotate(" + (e.axisY.flipTitle ? -90 : 90) + ", " + i + ", " + o + ")"; r = new n.Svg("text"), r.addClass(e.axisY.axisClass), r.text(e.axisY.axisTitle), r.attr({ x: i + e.axisY.offset.x, y: o + e.axisY.offset.y, transform: s, "text-anchor": e.axisY.textAnchor }), t.svg.append(r, !0) } }) } } }(window, document, Chartist), Chartist.plugins.ctAxisTitle });